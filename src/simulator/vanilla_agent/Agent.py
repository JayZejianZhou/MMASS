#!/usr/bin/env python
# 2020-12-14 Agent.py package main file, created and maintained by Zejian Zhou
import numpy as np
from simulator.fpk_solver.solver import fokker_planck
from simulator.fpk_solver.utility import boundary

class Agent(object):
    """ constructor
     init_state -- the initial states
     init_action -- the initial action
     dynam -- the system dynamics as a function handler
     dt -- the simulation segment duration"""

    def __init__(self, init_state, init_action=None, dt=0.01, dynam = None):
        self.state = init_state
        self.action = init_action
        self.dt = dt
        if dynam == None:
            self.dynam = self.__basic_dynam
        else:
            self.dynam = dynam


    """ basic linear dynamics
         action -- action"""
    def __basic_dynam(self, state, action):
        return state+action

    def __dynamics(self, action):
        self.state = self.state + self.dt * self.dynam(state=self.state, action=action) #update the state

    """ call this function to let the vanilla_agent run for one step
     action -- the control input list
     steps -- the step number """

    def move_steps(self, action, steps):
        states = []# save the trajectory
        for i in range(steps):
            states.append(self.state)
            self.__dynamics(action[i])
        return states

    """ this function solves FPK offline
        drift_force -- function handler for drift function in the FPK equation
        pdf -- the pdf generated by "gaussian_pdf" function
    """
    def solve_fpk(self, drift_force, pdf):
        self.nm = 1e-9
        self.pdf = pdf
        #generate the FPK solver instance
        #TODO: remove the temerature, and other unecessary inputs
        #TODO: remove the requirement of nm
        viscosity = 8e-4
        radius = 50 * self.nm
        drag = 1 * np.pi * viscosity * radius
        self.solver = fokker_planck(temperature=10, drag=1e-10, extent=[800 * self.nm, 800 * self.nm],
                    resolution=10 * self.nm, boundary=boundary.reflecting, force=drift_force)
        self.Nsteps = 500
        time, Pt = self.solver.propagate_interval(pdf, 20e-3, Nsteps=self.Nsteps)
        return Pt
    